//
// Requiem-Styles
// (c) VARIANTE (http://variante.io)
//
// This software is released under the MIT License:
// http://www.opensource.org/licenses/mit-license.php
//

//
// Clearfix hack for floated elements.
//
.clearfix() {
 //zoom: 1;

  &:before {
    content: '';
    display: table;
  }

  &:after {
    content: '';
    display: table;
    clear: both;
  }
}

//
// Transforms containing selector into a container that can freely align
// child inline-blocks with no fixed width/height requirements. Beware of
// whitespace between inline elements.
//
// @param  {List}   @alignH  Horizontal alignment of child elements (i.e. left,
//                           center, right). Option to specify left/right
//                           paddings respectively.
// @param  {List}   @alignV  Vertical alignment of child elements (i.e. top,
//                           center, bototm). Option to specify top/bottom
//                           paddings respectively.
// @param  {string} @inline  Specifies if this block is an inline block.
//
.fluid-block(@alignH:'center', @alignV:'center', @inline:false) {
  & when not (@alignH = '') and (length(@alignH) > 0) {
    & when (length(@alignH) > 1) { padding-left: extract(@alignH, 2);  }
    & when (length(@alignH) > 2) { padding-right: extract(@alignH, 3); }
  }

  & when not (@alignV = '') and (length(@alignV) > 0) {
    & when (length(@alignV) > 1) { padding-left: extract(@alignV, 2);  }
    & when (length(@alignV) > 2) { padding-right: extract(@alignV, 3); }
  }

  @h: extract(@alignH, 1);
  @v: extract(@alignV, 1);

  & when (@h = 'left')                    { text-align: left;   }
  & when (@h = 'center'), (@h = 'middle') { text-align: center; }
  & when (@h = 'right')                   { text-align: right;  }

  & when (@v = 'top')                     { vertical-align: top;    }
  & when (@v = 'center'), (@h = 'middle') { vertical-align: middle; }
  & when (@v = 'bottom')                  { vertical-align: bottom; }

  & when (@inline = true)     { display: inline-block; }
  & when not (@inline = true) { display: block;        }

  & > * {
    display: inline-block;
  }

  &:before {
    height: 100%;
    vertical-align: middle;
    content: '';
    display: inline-block;
  }
}

//
// Transforms containing selector into a flexbox which auto aligns child
// elements according to the specified params.
//
// @param  {List}    @alignH     Horizontal alignment of child elements (i.e.
//                               left, center, right). Option to specify
//                               left/right paddings respectively.
// @param  {List}    @alignV     Vertical alignment of child elements (i.e. top,
//                               middle, bottom). Option to specify top/bottom
//                               paddings respectively.
// @param  {boolean} @direction  Determines the main axis (i.e. row,
//                               row-reverse, column, column-reverse).
// @param  {boolean} @wrap       Determines if wrapping is enabled.
// @param  {string}  @inline     Specifies if this flexbox is inline.
//
.flex-block(@alignH:center, @alignV:center, @direction:row, @wrap:false, @inline:false) {
  & {
    line-height: normal;
    white-space: normal;
  }

  & when (@wrap = true)     { flex-wrap: wrap;   }
  & when not (@wrap = true) { flex-wrap: nowrap; }

  & when not (@alignH = ~'') and (length(@alignH) > 0) {
    & when (length(@alignH) > 1) { padding-left: extract(@alignH, 2);  }
    & when (length(@alignH) > 2) { padding-right: extract(@alignH, 3); }
  }

  & when not (@alignV = ~'') and (length(@alignV) > 0) {
    & when (length(@alignV) > 1) { padding-top: extract(@alignV, 2);    }
    & when (length(@alignV) > 2) { padding-bottom: extract(@alignV, 3); }
  }

  @h: extract(@alignH, 1);
  @v: extract(@alignV, 1);

  & when (@direction = 'row') {
    flex-direction: row;

    & when (@h = 'left')                    { justify-content: flex-start; }
    & when (@h = 'center'), (@h = 'middle') { justify-content: center;     }
    & when (@h = 'right')                   { justify-content: flex-end;   }

    & when (@v = 'top')                     { align-items: flex-start; }
    & when (@v = 'center'), (@v = 'middle') { align-items: center;     }
    & when (@v = 'bottom')                  { align-items: flex-end;   }
  }

  & when (@direction = 'row-reverse') {
    flex-direction: row-reverse;

    & when (@h = 'left')                    { justify-content: flex-end;   }
    & when (@h = 'center'), (@h = 'middle') { justify-content: center;     }
    & when (@h = 'right')                   { justify-content: flex-start; }

    & when (@v = 'top')                     { align-items: flex-start; }
    & when (@v = 'center'), (@v = 'middle') { align-items: center;     }
    & when (@v = 'bottom')                  { align-items: flex-end;   }
  }

  & when (@direction = 'column') {
    flex-direction: column;

    & when (@v = 'top')                     { justify-content: flex-start; }
    & when (@v = 'center'), (@v = 'middle') { justify-content: center;     }
    & when (@v = 'bottom')                  { justify-content: flex-end;   }

    & when (@h = 'left')                    { align-items: flex-start; }
    & when (@h = 'center'), (@h = 'middle') { align-items: center;     }
    & when (@h = 'right')                   { align-items: flex-end;   }
  }

  & when (@direction = 'column-reverse') {
    flex-direction: column-reverse;

    & when (@v = 'top')                     { justify-content: flex-end;   }
    & when (@v = 'center'), (@v = 'middle') { justify-content: center;     }
    & when (@v = 'bottom')                  { justify-content: flex-start; }

    & when (@h = 'left')                    { align-items: flex-start; }
    & when (@h = 'center'), (@h = 'middle') { align-items: center;     }
    & when (@h = 'right')                   { align-items: flex-end;   }
  }

  & when (@inline = true)     { display: inline-flex; }
  & when not (@inline = true) { display: flex;        }
}

//
// Aligns containing selector to specified x/y directions in absolute position.
//
// @param {List} @alignH  Horizontal alignment (left|center|right, left|right
//                        offset, right offset).
// @param {List} @alignV  Vertical alignment (top|center|middle|bottom,
//                        top|bottom offset, bottom offset).
//
.abs-align(@alignH:'left', @alignV:'top') {
  & {
    position: absolute;
  }

  & when not (@alignH = ~'') and (length(@alignH) > 0) {
    @align: extract(@alignH, 1);
    @offset1: ~'';
    @offset2: ~'';

    & when (length(@alignH) > 1) { @offset1: extract(@alignH, 2); }
    & when (length(@alignH) > 2) { @offset2: extract(@alignH, 3); }

    & when (@align = 'left') {
      & when (@offset1 = ~'')     { left: 0px;      }
      & when not (@offset1 = ~'') { left: @offset1; }
      right: initial;
    }

    & when (@align = 'center'), (@align = 'middle') {
      margin-left: auto;
      margin-right: auto;
      & when (@offset1 = ~'')     { left: 0px;       }
      & when not (@offset1 = ~'') { left: @offset1;  }
      & when (@offset2 = ~'')     { right: 0px;      }
      & when not (@offset2 = ~'') { right: @offset2; }
    }

    & when (@align = 'right') {
      & when (@offset1 = ~'')     { right: 0px;      }
      & when not (@offset1 = ~'') { right: @offset1; }
      left: initial;
    }
  }

  & when not (@alignV = ~'') and (length(@alignV) > 0) {
    @align: extract(@alignV, 1);
    @offset1: ~'';
    @offset2: ~'';

    & when (length(@alignV) > 1) { @offset1: extract(@alignV, 2); }
    & when (length(@alignV) > 2) { @offset2: extract(@alignV, 3); }

    & when (@align = 'top') {
      & when (@offset1 = ~'')     { top: 0px;      }
      & when not (@offset1 = ~'') { top: @offset1; }
    }

    & when (@align = 'center'), (@align = 'middle') {
      margin-top: auto;
      margin-bottom: auto;
      & when (@offset1 = ~'')     { top: 0px;         }
      & when not (@offset1 = ~'') { top: @offset1;    }
      & when (@offset2 = ~'')     { bottom: 0px;      }
      & when not (@offset2 = ~'') { bottom: @offset2; }
    }

    & when (@align = 'bottom') {
      & when (@offset1 = ~'')     { bottom: 0px;      }
      & when not (@offset1 = ~'') { bottom: @offset1; }
    }
  }
}

//
// Aligns containing selector to specified x/y directions in fixed position.
//
// @param {List} @alignH  Horizontal alignment (left|center|right, left|right
//                        offset, right offset).
// @param {List} @alignV  Vertical alignment (top|center|middle|bottom,
//                        top|bottom offset, bottom offset).
//
.fixed-align(@alignH:'left', @alignV:'top') {
  position: fixed;

  & when not (@alignH = ~'') and (length(@alignH) > 0) {
    @align: extract(@alignH, 1);
    @offset1: ~'';
    @offset2: ~'';

    & when (length(@alignH) > 1) { @offset1: extract(@alignH, 2); }
    & when (length(@alignH) > 2) { @offset2: extract(@alignH, 3); }

    & when (@align = 'left') {
      & when (@offset1 = ~'')     { left: 0px;      }
      & when not (@offset1 = ~'') { left: @offset1; }
    }

    & when (@align = 'center'), (@align = 'middle') {
      margin-left: auto;
      margin-right: auto;
      & when (@offset1 = ~'')     { left: 0px;       }
      & when not (@offset1 = ~'') { left: @offset1;  }
      & when (@offset2 = ~'')     { right: 0px;      }
      & when not (@offset2 = ~'') { right: @offset2; }
    }

    & when (@align = 'right') {
      & when (@offset1 = ~'')     { right: 0px;      }
      & when not (@offset1 = ~'') { right: @offset1; }
    }
  }

  & when not (@alignV = ~'') and (length(@alignV) > 0) {
    @align: extract(@alignV, 1);
    @offset1: ~'';
    @offset2: ~'';

    & when (length(@alignV) > 1) { @offset1: extract(@alignV, 2); }
    & when (length(@alignV) > 2) { @offset2: extract(@alignV, 3); }

    & when (@align = 'top') {
      & when (@offset1 = ~'')     { top: 0px;      }
      & when not (@offset1 = ~'') { top: @offset1; }
    }

    & when (@align = 'center'), (@align = 'middle') {
      margin-top: auto;
      margin-bottom: auto;
      & when (@offset1 = ~'')     { top: 0px;         }
      & when not (@offset1 = ~'') { top: @offset1;    }
      & when (@offset2 = ~'')     { bottom: 0px;      }
      & when not (@offset2 = ~'') { bottom: @offset2; }
    }

    & when (@align = 'bottom') {
      & when (@offset1 = ~'')     { bottom: 0px;      }
      & when not (@offset1 = ~'') { bottom: @offset1; }
    }
  }
}

//
// Aligns containing inline-block to specified x/y directions in relative
// position.
//
// @param {string} @alignH     Horizontal alignment (i.e. left, center, right).
// @param {string} @alignV     Vertical alignment (i.e. top, middle, bottom).
//
.inline-align(@alignH:'left', @alignV:'top') {
  position: relative;

  // Horizontal alignment cannot be altered at the child level. Tweak the
  // parent's text-align rule instead.

  & when (@alignV = 'top')                            { vertical-align: top;    }
  & when (@alignV = 'center'), (@alignV = 'middle') { vertical-align: middle; }
  & when (@alignV = 'bottom')                         { vertical-align: bottom; }
}

//
// Transforms target selector into a container for parallax elements.
//
// @param {number} @perspective    Tweak this value to adjust perspective.
//
// @see parallax-element
//
.parallax-block(@perspective:1) {
  height: 100vh;
  overflow-x: hidden;
  overflow-y: scroll;
  perspective: unit(@perspective, px);
}

//
// Transforms target selector into a parallax element. The target selector must
// be a child of a parallax-block.
//
// @param {string} @type  Layer type, either 'group' or 'layer'.
// @param {number} @z     Position in the z-axis.
//
// @see parallax-block
//
.parallax-element(@type:layer, @z:0) {
  & when (@type = 'group') {
    height: 100vh;
    position: relative;
    transform-style: preserve-3d;
  }

  & when (@type = 'layer') {
    transform: translateZ(unit(@z, px));
  }
}

//
// Sets the diameter of the target selector.
//
// @param {number}  @diameter
// @param {boolean} @oval
//
.diameter(@diameter, @oval:false) {
  width: @diameter;
  height: @diameter;

  & when (@oval = true) {
    border-radius: @diameter / 2;
    overflow: hidden;
    -webkit-mask-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYGBgAAgwAAAEAAGbA+oJAAAAAElFTkSuQmCC);
  }
}

//
// Applies mask to target selector.
//
.mask() {
  overflow: hidden;
  -webkit-mask-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYGBgAAgwAAAEAAGbA+oJAAAAAElFTkSuQmCC);
}

//
// Hides the target selector.
//
.hidden() {
  display: none !important;
}

//
// Makes the target selector invisible.
//
.invisible() {
  visibility: hidden !important;
}

//
// Fits dimension to parent container.
//
// @param {boolean} @w  Specifies whether to fit the width.
// @param {boolean} @h  Specifies whether to fit the height.
//
.auto-fit(@w:true, @h:true) {
  & when (@w = true) {
    width: 100%;
  }

  & when (@h = true) {
    height: 100%;
  }
}
